{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@babel/runtime/helpers/esm/extends.js","webpack:///./node_modules/@hullo/browser/ofHistory.js","webpack:///./node_modules/@hullo/browser/route.js","webpack:///./node_modules/@hullo/core/atom.js","webpack:///./node_modules/@hullo/core/channel.js","webpack:///./node_modules/@hullo/core/combineLatest.js","webpack:///./node_modules/@hullo/core/duplex.js","webpack:///./node_modules/@hullo/core/observable.js","webpack:///./node_modules/@hullo/core/of.js","webpack:///./node_modules/@hullo/core/operators/deepMap.js","webpack:///./node_modules/@hullo/core/operators/distinct.js","webpack:///./node_modules/@hullo/core/operators/map.js","webpack:///./node_modules/@hullo/core/operators/state.js","webpack:///./node_modules/@hullo/core/operators/subject.js","webpack:///./node_modules/@hullo/dom/element.js","webpack:///./node_modules/@hullo/dom/h.js","webpack:///./node_modules/@hullo/dom/html.js","webpack:///./node_modules/@hullo/dom/index.js","webpack:///./node_modules/@hullo/dom/mount.js","webpack:///./node_modules/@hullo/dom/render.js","webpack:///./node_modules/@hullo/dom/svg.js","webpack:///./node_modules/history/esm/history.js","webpack:///./node_modules/resolve-pathname/index.js","webpack:///./node_modules/tiny-invariant/dist/tiny-invariant.esm.js","webpack:///./node_modules/tiny-warning/dist/tiny-warning.esm.js","webpack:///./node_modules/value-equal/index.js","webpack:///./ts/Adder.ts","webpack:///./ts/App.ts","webpack:///./ts/Footer.ts","webpack:///./ts/List.ts","webpack:///./ts/Main.ts","webpack:///./ts/filters.ts","webpack:///./ts/index.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAe;AACf;AACA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AChBa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,wEAAwB;AACrD,iBAAiB,mBAAO,CAAC,gEAAoB;AAC7C,gBAAgB,mBAAO,CAAC,kFAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Ca;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,wEAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,sDAAU;AACnC,qBAAqB,mBAAO,CAAC,8DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,sDAAU;AACnC,qBAAqB,mBAAO,CAAC,8DAAc;AAC3C,kBAAkB,mBAAO,CAAC,4EAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ga;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,8DAAc;AAC3C,cAAc,mBAAO,CAAC,oEAAiB;AACvC,aAAa,mBAAO,CAAC,8CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,OAAO;AAChF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ja;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,qBAAqB,mBAAO,CAAC,8DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChHa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,8DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;ACjJa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,+DAAe;AAC5C,eAAe,mBAAO,CAAC,mDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,uBAAuB,8CAA8C;AACrE;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Fa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,+DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,+DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Ca;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,+DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sCAAsC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3Ga;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,+DAAe;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;;;;;;;;;;;;;AChBa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,uDAAW;AACrC;AACA;AACA;AACA,wDAAwD,qBAAqB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACba;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,uDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2CAA2C;;;;;;;;;;;;;AC3H/B;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,uDAAW;AAC5B,SAAS,mBAAO,CAAC,2CAAK;AACtB,SAAS,mBAAO,CAAC,iDAAQ;AACzB,SAAS,mBAAO,CAAC,mDAAS;AAC1B,SAAS,mBAAO,CAAC,qDAAU;AAC3B,SAAS,mBAAO,CAAC,+CAAO;;;;;;;;;;;;;ACVX;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,qDAAU;AACnC;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,wEAAwB;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,WAAW,wCAAwC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C;AACA;AACA,mBAAmB,gDAAgD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,gBAAgB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,gBAAgB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,8CAA8C;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1aa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,uDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;;;;;;;;;;;;;ACtGzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0D;AACX;AACV;AACF;AACI;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,kFAAQ,GAAG;AAC1B;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,gEAAe;AACzC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uGAAuG,2DAAU;AACjH;;AAEA;AACA;;AAEA;AACA,IAAI,KAAqC,GAAG,4DAAO,mEAAmE,SAAM;AAC5H;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,UAAU,KAAqC,GAAG,4DAAO,6FAA6F,SAAM;AAC5J;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,uEAAuE,aAAa;AACpF;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,eAAe,KAAqC,GAAG,8DAAS,yCAAyC,SAAgB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAqC,GAAG,4DAAO,oNAAoN,SAAM;AAC7Q;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI,kFAAQ;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;;AAEA;AACA,IAAI,KAAqC,GAAG,4DAAO,sNAAsN,mBAAmB,SAAM;AAClS;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,QAAQ,KAAqC,GAAG,4DAAO,2GAA2G,SAAM;AACxK;AACA;AACA,KAAK;AACL;;AAEA;AACA,IAAI,KAAqC,GAAG,4DAAO,yNAAyN,mBAAmB,SAAM;AACrS;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,QAAQ,KAAqC,GAAG,4DAAO,8GAA8G,SAAM;AAC3K;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,KAAqC,GAAG,8DAAS,sCAAsC,SAAgB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,KAAqC,GAAG,4DAAO,oNAAoN,SAAM;AAC7Q;AACA;AACA;;AAEA;;AAEA;AACA,IAAI,kFAAQ;;AAEZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6EAA6E;;AAE7E,sDAAsD,uBAAuB;;AAE7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;;AAEA;AACA,IAAI,KAAqC,GAAG,4DAAO,sDAAsD,mBAAmB,SAAM;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,QAAQ,KAAqC,GAAG,4DAAO,gDAAgD,wDAAwD,SAAM;AACrK;AACA;AACA,KAAK;AACL;;AAEA;AACA,IAAI,KAAqC,GAAG,4DAAO,yDAAyD,mBAAmB,SAAM;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,IAAI,KAAqC,GAAG,4DAAO,uFAAuF,SAAM;AAChJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,kFAAQ;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,EAAE;;AAEL;;AAEA;AACA,IAAI,KAAqC,GAAG,4DAAO,sNAAsN,mBAAmB,SAAM;AAClS;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,IAAI,KAAqC,GAAG,4DAAO,yNAAyN,mBAAmB,SAAM;AACrS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./ts/index.ts\");\n","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"@hullo/core/observable\");\nconst duplex_1 = require(\"@hullo/core/duplex\");\nconst state_1 = require(\"@hullo/core/operators/state\");\nfunction ofHistory(history) {\n    const acks = [];\n    return new duplex_1.Duplex(new observable_1.Observable(new HistoryProducer(history, acks)).pipe(state_1.state(history.location)), new HistoryInput(history, acks));\n}\nexports.ofHistory = ofHistory;\nclass HistoryProducer {\n    constructor(history, acks) {\n        this.history = history;\n        this.acks = acks;\n    }\n    subscribe(observer) {\n        return this.history.listen((location, _action) => {\n            const acks = this.acks.splice(0);\n            observer.next(location).then(() => {\n                acks.forEach(call);\n            });\n        });\n    }\n}\nfunction call(f) {\n    f();\n}\nclass HistoryInput {\n    constructor(history, acks) {\n        this.history = history;\n        this.acks = acks;\n    }\n    get closed() {\n        return false;\n    }\n    next(next) {\n        return new Promise(resolve => {\n            this.acks.push(resolve);\n            this.history.push(next);\n        });\n    }\n    complete() {\n        return Promise.resolve();\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"@hullo/core/observable\");\nfunction route(config) {\n    return function routeI(source) {\n        return new observable_1.Observable(new RouteProducer(source, config));\n    };\n}\nexports.route = route;\nclass RouteProducer {\n    constructor(source, config) {\n        this.source = source;\n        this.config = config;\n    }\n    subscribe(observer) {\n        const sub = this.source.subscribe(new RouteObserver(this.config, observer));\n        return new RoutingCancel(sub);\n    }\n}\nclass RoutingCancel {\n    constructor(sub) {\n        this.sub = sub;\n    }\n    cancel() {\n        if (!this.sub.closed) {\n            this.sub.cancel();\n        }\n    }\n}\nclass RouteObserver {\n    constructor(config, observer) {\n        this.config = config;\n        this.observer = observer;\n    }\n    get closed() {\n        return this.observer.closed;\n    }\n    next(location) {\n        if (typeof location.pathname === \"string\") {\n            for (const { when, have } of this.config) {\n                const result = when.exec(location.pathname);\n                if (result) {\n                    return this.observer.next(have(result.slice(1)));\n                }\n            }\n        }\n        return Promise.resolve();\n    }\n    complete() {\n        return this.observer.complete();\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst duplex_1 = require(\"./duplex\");\nconst observable_1 = require(\"./observable\");\nclass Atom extends duplex_1.Duplex {\n    constructor(state) {\n        const context = {\n            closed: false,\n            remotes: [],\n            state: { ref: state }\n        };\n        const out = new observable_1.Observable(new AtomProducer(context));\n        const ins = new AtomObserver(context);\n        super(out, ins);\n        this.context = context;\n        this.lastUpdate = Promise.resolve();\n    }\n    valueOf() {\n        return this.context.state.ref;\n    }\n    unwrap() {\n        return this.context.state.ref;\n    }\n    update(xf) {\n        return (this.lastUpdate = this.lastUpdate\n            .then(() => xf(this.context.state.ref))\n            .then(result => {\n            return this.next(result);\n        }));\n    }\n}\nexports.Atom = Atom;\nclass AtomProducer {\n    constructor(context) {\n        this.context = context;\n    }\n    subscribe(observer) {\n        if (this.context.closed) {\n            observer.complete();\n        }\n        else {\n            this.context.remotes.push(observer);\n            const { state } = this.context;\n            Promise.resolve().then(() => {\n                if (this.context.state === state) {\n                    observer.next(this.context.state.ref);\n                }\n            });\n            return new AtomCancel(this.context, observer);\n        }\n    }\n}\nclass AtomCancel {\n    constructor(context, observer) {\n        this.context = context;\n        this.observer = observer;\n    }\n    cancel() {\n        this.context.remotes.splice(this.context.remotes.indexOf(this.observer), 1);\n    }\n}\nclass AtomObserver {\n    constructor(context) {\n        this.context = context;\n    }\n    get closed() {\n        return this.context.closed;\n    }\n    next(ref) {\n        if (this.context.closed) {\n            return Promise.resolve();\n        }\n        this.context.state = { ref };\n        return this.context.remotes.length\n            ? Promise.all(this.context.remotes.map(remote => remote.next(ref)))\n            : Promise.resolve();\n    }\n    complete() {\n        if (this.closed) {\n            return Promise.resolve();\n        }\n        this.context.closed = true;\n        return this.context.remotes.length\n            ? Promise.all(this.context.remotes.map(remote => remote.complete()))\n            : Promise.resolve();\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst duplex_1 = require(\"./duplex\");\nconst observable_1 = require(\"./observable\");\nconst subject_1 = require(\"./operators/subject\");\nclass Channel extends duplex_1.Duplex {\n    constructor() {\n        const context = {\n            buffer: [],\n            closed: false,\n            remote: undefined,\n            nextSafeHandlers: [],\n            nextUnsafeHandlers: []\n        };\n        const out = new observable_1.Observable(new ChannelProducer(context)).pipe(subject_1.subject);\n        const ins = new ChannelObserver(context);\n        super(out, ins);\n        this.context = context;\n    }\n    take() {\n        return new Promise((resolve, reject) => {\n            this.context.nextUnsafeHandlers.push({ resolve, reject });\n            Promise.resolve(this.context).then(flushBuffer);\n        });\n    }\n    tryTake() {\n        return new Promise(resolve => {\n            this.context.nextSafeHandlers.push(resolve);\n            Promise.resolve(this.context).then(flushBuffer);\n        });\n    }\n}\nexports.Channel = Channel;\nclass ChannelObserver {\n    constructor(context) {\n        this.context = context;\n    }\n    get closed() {\n        return this.context.closed;\n    }\n    next(value) {\n        return deliver(this.context, {\n            closed: false,\n            value\n        });\n    }\n    complete() {\n        return deliver(this.context, {\n            closed: true\n        });\n    }\n}\nclass ChannelProducer {\n    constructor(wide) {\n        this.wide = wide;\n    }\n    subscribe(observer) {\n        if (this.wide.closed) {\n            observer.complete();\n        }\n        else {\n            this.wide.remote = observer;\n            Promise.resolve(this.wide).then(flushBuffer);\n            return new ChannelCancel(this.wide);\n        }\n    }\n}\nclass ChannelCancel {\n    constructor(wide) {\n        this.wide = wide;\n    }\n    cancel() {\n        this.wide.remote = undefined;\n    }\n}\nfunction flushBuffer(wideContext) {\n    for (const { message, ack } of wideContext.buffer.splice(0)) {\n        deliver(wideContext, message).then(ack);\n    }\n}\nfunction deliver(context, message) {\n    if (context.closed) {\n        return Promise.resolve();\n    }\n    if (context.nextSafeHandlers.length === 0 &&\n        context.nextUnsafeHandlers.length === 0 &&\n        !context.remote) {\n        return new Promise(ack => {\n            context.buffer.push({ message, ack });\n        });\n    }\n    if (message.closed) {\n        context.closed = true;\n    }\n    for (const handler of context.nextSafeHandlers.splice(0)) {\n        handler(message);\n    }\n    if (message.closed) {\n        for (const handler of context.nextUnsafeHandlers.splice(0)) {\n            handler.reject(new Error(\"Channel closed before it got a message\"));\n        }\n        return context.remote ? context.remote.complete() : Promise.resolve();\n    }\n    else {\n        for (const handler of context.nextUnsafeHandlers.splice(0)) {\n            handler.resolve(message.value);\n        }\n        return context.remote\n            ? context.remote.next(message.value)\n            : Promise.resolve();\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"./observable\");\nconst map_1 = require(\"./operators/map\");\nconst of_1 = require(\"./of\");\nfunction combineLatest(streams) {\n    if (streams.length === 0) {\n        return of_1.of([[]]);\n    }\n    if (streams.length === 1) {\n        return streams[0].pipe(map_1.map(singleToArrayOfOne));\n    }\n    return new observable_1.Observable(new CombineLatestProducer(streams));\n}\nexports.combineLatest = combineLatest;\nfunction singleToArrayOfOne(v) {\n    return [v];\n}\nclass CombineLatestProducer {\n    constructor(streams) {\n        this.streams = streams;\n    }\n    subscribe(observer) {\n        const context = {\n            closed: false,\n            streams: this.streams,\n            subs: [],\n            everyOk: this.streams.map(() => false),\n            allOk: false,\n            values: [],\n            frame: undefined,\n            observer\n        };\n        for (let i = 0, l = context.streams.length; i < l; i++) {\n            context.subs[i] = context.streams[i].subscribe(new CombineLatestEntryObserver(context, i));\n        }\n        return new CombineLatestCancel(context);\n    }\n}\nclass CombineLatestCancel {\n    constructor(context) {\n        this.context = context;\n    }\n    cancel() {\n        this.context.closed = true;\n        for (let i = 0, l = this.context.subs.length; i < l; i++) {\n            if (!this.context.subs[i].closed) {\n                this.context.subs[i].cancel();\n            }\n        }\n    }\n}\nclass CombineLatestEntryObserver {\n    constructor(_context, _position) {\n        this._context = _context;\n        this._position = _position;\n    }\n    get closed() {\n        return this._context.closed;\n    }\n    next(value) {\n        if (this._context.closed) {\n            return Promise.resolve();\n        }\n        if (this._context.frame && this._context.frame.completion) {\n            const frame = this._context.frame;\n            return new Promise(r => frameDeliveryProducer(frame, r));\n        }\n        const values = this._context.values.slice(0);\n        values[this._position] = value;\n        const frame = {\n            sent: false,\n            completion: false,\n            values,\n            merged: this._context.frame\n        };\n        this._context.frame = frame;\n        this._context.values = values;\n        if (!this._context.allOk) {\n            if (!this._context.everyOk[this._position]) {\n                this._context.everyOk[this._position] = true;\n                this._context.allOk = true;\n                for (let i = 0, l = this._context.everyOk.length; i < l; i++) {\n                    if (!this._context.everyOk[i]) {\n                        this._context.allOk = false;\n                        break;\n                    }\n                }\n            }\n        }\n        if (this._context.allOk) {\n            Promise.resolve(this._context).then(send);\n        }\n        return new Promise(r => frameDeliveryProducer(frame, r));\n    }\n    complete() {\n        if (this._context.closed) {\n            return Promise.resolve();\n        }\n        if (this._context.frame && this._context.frame.completion) {\n            const frame = this._context.frame;\n            return new Promise(r => frameDeliveryProducer(frame, r));\n        }\n        const frame = {\n            sent: false,\n            completion: true,\n            values: this._context.values,\n            merged: this._context.frame\n        };\n        this._context.frame = frame;\n        Promise.resolve(this._context).then(send);\n        for (let i = 0, l = this._context.subs.length; i < l; i++) {\n            if (i !== this._position && !this._context.subs[i].closed) {\n                this._context.subs[i].cancel();\n            }\n        }\n        return new Promise(r => frameDeliveryProducer(frame, r));\n    }\n}\nfunction send(context) {\n    if (context.closed || !context.frame || !context.observer) {\n        return;\n    }\n    const frame = context.frame;\n    context.frame = undefined;\n    if (frame.completion) {\n        context.closed = true;\n    }\n    (frame.completion\n        ? context.observer.complete()\n        : context.observer.next(frame.values)).then(() => frameDeliveryConfirmations(frame));\n}\nfunction frameDeliveryProducer(frame, resolve) {\n    if (frame.sent) {\n        resolve();\n    }\n    else {\n        if (frame.acks) {\n            frame.acks.push(resolve);\n        }\n        else {\n            frame.acks = [resolve];\n        }\n    }\n}\nfunction frameDeliveryConfirmations(frame) {\n    let innerFrame = frame;\n    while (innerFrame) {\n        innerFrame.sent = true;\n        for (let i = 0, l = innerFrame.acks ? innerFrame.acks.length : 0; i < l; i += 1) {\n            innerFrame.acks[i]();\n        }\n        innerFrame = innerFrame.merged;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _a;\n\"use strict\";\nconst observable_1 = require(\"./observable\");\nconst duplexSymbol = Symbol(\"is Duplex\");\nclass Duplex extends observable_1.Observable {\n    constructor(observable, observer) {\n        super(Duplex.prototype.duplexProduce);\n        this.observable = observable;\n        this.observer = observer;\n        this[_a] = true;\n    }\n    duplexProduce(observer) {\n        return this.observable.subscribe(observer);\n    }\n    get closed() {\n        return this.observer.closed;\n    }\n    next(value) {\n        return this.observer.next(value);\n    }\n    complete() {\n        return this.observer.complete();\n    }\n}\n_a = duplexSymbol;\nexports.Duplex = Duplex;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _a;\n\"use strict\";\nexports.observableSymbol = Symbol(\"is observable\");\nclass Observable {\n    constructor(produce) {\n        this.produce = produce;\n        this[_a] = true;\n    }\n    static isObservable(o) {\n        return o != null && typeof o === \"object\" && o[exports.observableSymbol];\n    }\n    subscribe(observer) {\n        const observation = {\n            stage: Stage.active,\n            subscriber: observer\n        };\n        const sub = new BaseSubscription(observation);\n        const teardown = typeof this.produce === \"function\"\n            ? this.produce(new BaseObserver(observation))\n            : this.produce.subscribe(new BaseObserver(observation));\n        if (isTeardown(teardown)) {\n            observation.teardown = teardown;\n        }\n        return sub;\n    }\n    pipe(transducer) {\n        return transducer(this);\n    }\n}\n_a = exports.observableSymbol;\nexports.Observable = Observable;\nclass BaseSubscription {\n    constructor(observation) {\n        this.observation = observation;\n    }\n    get closed() {\n        const { stage } = this.observation;\n        return stage === Stage.cancelled || stage === Stage.completed;\n    }\n    cancel() {\n        this.observation.stage = Stage.cancelled;\n        const { teardown, sending } = this.observation;\n        if (teardown) {\n            (sending || Promise.resolve()).then(() => {\n                doTeardown(teardown);\n            });\n        }\n    }\n}\nclass BaseObserver {\n    constructor(observation) {\n        this.observation = observation;\n    }\n    get closed() {\n        return this.observation.stage !== Stage.active;\n    }\n    next(value) {\n        const { stage, subscriber, sending } = this.observation;\n        if (stage !== Stage.active || !subscriber.next) {\n            return Promise.resolve();\n        }\n        if (sending) {\n            return sending.then(() => {\n                this.observation.sending = undefined;\n                return this.next(value);\n            });\n        }\n        const nextSending = subscriber.next(value) || undefined;\n        this.observation.sending = nextSending;\n        return nextSending || Promise.resolve();\n    }\n    complete() {\n        const { stage, subscriber, sending } = this.observation;\n        if (stage !== Stage.active || !subscriber.complete) {\n            return Promise.resolve();\n        }\n        if (sending) {\n            return sending.then(() => {\n                this.observation.sending = undefined;\n                return this.complete();\n            });\n        }\n        this.observation.stage = Stage.completed;\n        const nextSending = subscriber.complete() || undefined;\n        this.observation.sending = nextSending;\n        return nextSending || Promise.resolve();\n    }\n}\nvar Stage;\n(function (Stage) {\n    Stage[Stage[\"active\"] = 0] = \"active\";\n    Stage[Stage[\"completed\"] = 1] = \"completed\";\n    Stage[Stage[\"cancelled\"] = 2] = \"cancelled\";\n})(Stage || (Stage = {}));\nfunction doTeardown(t) {\n    if (t && typeof t === \"function\") {\n        t();\n        return;\n    }\n    if (t &&\n        typeof t === \"object\" &&\n        \"cancel\" in t &&\n        typeof t.cancel === \"function\") {\n        t.cancel();\n        return;\n    }\n}\nfunction isTeardown(t) {\n    return (t != null &&\n        (typeof t === \"function\" || (typeof t === \"object\" && \"cancel\" in t)));\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"./observable\");\nfunction of(source, autoclose = true) {\n    if (typeof source === \"object\" && Symbol.asyncIterator in source) {\n        const asyncSource = source;\n        return new observable_1.Observable(new AsyncSourceProducer(asyncSource, autoclose));\n    }\n    if (typeof source === \"object\" && Symbol.iterator in source) {\n        const syncSource = source;\n        return new observable_1.Observable(new SyncSourceProducer(syncSource, autoclose));\n    }\n    const unitSource = source;\n    return new observable_1.Observable(new UnitProducer(unitSource, autoclose));\n}\nexports.of = of;\nclass AsyncSourceProducer {\n    constructor(source, autoclose) {\n        this.source = source;\n        this.autoclose = autoclose;\n    }\n    subscribe(observer) {\n        const context = {\n            observer,\n            asyncIterable: this.source,\n            asyncIterator: this.source[Symbol.asyncIterator](),\n            retrieving: false,\n            drained: false,\n            cancelled: false,\n            autoclose: this.autoclose\n        };\n        asyncSourceIterate(context);\n        return new AsyncSourceCancel(context);\n    }\n}\nfunction asyncSourceIterate(context) {\n    if (context.cancelled &&\n        context.asyncIterator &&\n        context.asyncIterator.return) {\n        context.asyncIterator.return();\n    }\n    if (context.cancelled || context.drained) {\n        return;\n    }\n    context.retrieving = true;\n    context.asyncIterator\n        .next()\n        .then(iteration => resultHandler(context, iteration));\n}\nfunction resultHandler(context, iteration) {\n    context.retrieving = false;\n    if (context.cancelled &&\n        context.asyncIterator &&\n        context.asyncIterator.return) {\n        context.asyncIterator.return();\n    }\n    if (context.drained || context.cancelled) {\n        return;\n    }\n    if (iteration.done) {\n        context.drained = true;\n        if (context.autoclose) {\n            context.observer.complete();\n        }\n    }\n    else {\n        context.observer\n            .next(iteration.value)\n            .then(() => asyncSourceIterate(context));\n    }\n}\nclass AsyncSourceCancel {\n    constructor(context) {\n        this.context = context;\n    }\n    cancel() {\n        this.context.cancelled = true;\n        if (!this.context.retrieving &&\n            this.context.asyncIterator &&\n            this.context.asyncIterator.return) {\n            this.context.asyncIterator.return();\n        }\n    }\n}\nclass SyncSourceProducer {\n    constructor(source, autoclose) {\n        this.source = source;\n        this.autoclose = autoclose;\n    }\n    subscribe(observer) {\n        const context = {\n            observer,\n            iterable: this.source,\n            drained: false,\n            cancelled: false,\n            autoclose: this.autoclose\n        };\n        syncSourceIterate(context);\n        return new SyncSourceCancel(context);\n    }\n}\nfunction syncSourceIterate(context) {\n    if (context.drained || context.cancelled) {\n        return;\n    }\n    const iteration = (context.iterator || (context.iterator = context.iterable[Symbol.iterator]())).next();\n    if (iteration.done) {\n        context.drained = true;\n        if (context.autoclose) {\n            context.observer.complete();\n        }\n    }\n    else {\n        context.observer\n            .next(iteration.value)\n            .then(() => syncSourceIterate(context));\n    }\n}\nclass SyncSourceCancel {\n    constructor(context) {\n        this.context = context;\n    }\n    cancel() {\n        this.context.cancelled = true;\n        if (this.context.iterator && this.context.iterator.return) {\n            this.context.iterator.return();\n        }\n    }\n}\n// ::of single value\nclass UnitProducer {\n    constructor(value, autoclose) {\n        this.value = value;\n        this.autoclose = autoclose;\n    }\n    subscribe(observer) {\n        observer.next(this.value).then(() => {\n            if (observer.closed) {\n                return;\n            }\n            if (this.autoclose) {\n                observer.complete();\n            }\n        });\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"../observable\");\nconst atom_1 = require(\"../atom\");\nfunction deepMap(xf) {\n    return function deepMapI(source) {\n        return new observable_1.Observable(new DeepMapProducer(xf, source));\n    };\n}\nexports.deepMap = deepMap;\nclass DeepMapProducer {\n    constructor(xf, source) {\n        this.xf = xf;\n        this.source = source;\n    }\n    subscribe(observer) {\n        const context = {\n            observer,\n            xf: this.xf,\n            source: this.source,\n            detail$s: [],\n            output: [],\n            lastInput: []\n        };\n        const sub = this.source.subscribe(new DeepMapSourceObserver(context));\n        return new DeepMapCancel(sub);\n    }\n}\nclass DeepMapCancel {\n    constructor(sub) {\n        this.sub = sub;\n    }\n    cancel() {\n        if (!this.sub.closed) {\n            this.sub.cancel();\n        }\n    }\n}\nclass DeepMapSourceObserver {\n    constructor(context) {\n        this.context = context;\n    }\n    get closed() {\n        return this.context.observer.closed;\n    }\n    next(list) {\n        const { context } = this;\n        const deliveries = [];\n        let needsToPushOutput = false;\n        for (let i = 0; i < list.length && i < context.output.length; i++) {\n            if (context.detail$s[i].unwrap() !== list[i]) {\n                const delivery = context.detail$s[i].next(list[i]);\n                deliveries.push(delivery);\n            }\n        }\n        for (let i = context.output.length, l = list.length; i < l; i++) {\n            needsToPushOutput = true;\n            const detail$ = new atom_1.Atom(list[i]);\n            context.detail$s.push(detail$);\n            context.output.push(context.xf(detail$, i));\n            const delivery = detail$.next(list[i]);\n            deliveries.push(delivery);\n        }\n        for (let i = list.length, l = context.output.length; i < l; i++) {\n            needsToPushOutput = true;\n            const delivery = context.detail$s[i].complete();\n            deliveries.push(delivery);\n        }\n        context.detail$s.splice(list.length);\n        context.output.splice(list.length);\n        if (needsToPushOutput && context.observer) {\n            const delivery = context.observer.next(context.output.slice(0));\n            deliveries.push(delivery);\n        }\n        return deliveries.length ? Promise.all(deliveries) : Promise.resolve();\n    }\n    complete() {\n        const { context } = this;\n        if (!context.observer) {\n            return Promise.resolve();\n        }\n        const deliveries = [];\n        for (let i = 0, l = context.detail$s.length; i < l; i++) {\n            const delivery = context.detail$s[i].complete();\n            deliveries.push(delivery);\n        }\n        {\n            const delivery = context.observer.complete();\n            deliveries.push(delivery);\n        }\n        return Promise.all(deliveries);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"../observable\");\nfunction distinctEqual(source) {\n    return new observable_1.Observable(new DistinctProducer(source, equal));\n}\nexports.distinctEqual = distinctEqual;\nfunction equal(p, n) {\n    return p != n;\n}\nfunction distinctStrictEqual(source) {\n    return new observable_1.Observable(new DistinctProducer(source, strictEqual));\n}\nexports.distinctStrictEqual = distinctStrictEqual;\nfunction strictEqual(p, n) {\n    return p !== n;\n}\nfunction distinct(compare) {\n    return function distinctI(source) {\n        return new observable_1.Observable(new DistinctProducer(source, compare));\n    };\n}\nexports.distinct = distinct;\nclass DistinctProducer {\n    constructor(source, compare) {\n        this.source = source;\n        this.compare = compare;\n    }\n    subscribe(observer) {\n        const sub = this.source.subscribe(new DistinctSourceObserver(observer, this.compare));\n        return new DistinctCancel(sub);\n    }\n}\nclass DistinctCancel {\n    constructor(sub) {\n        this.sub = sub;\n    }\n    cancel() {\n        if (!this.sub.closed) {\n            this.sub.cancel();\n        }\n    }\n}\nclass DistinctSourceObserver {\n    constructor(outerObserver, compare) {\n        this.outerObserver = outerObserver;\n        this.compare = compare;\n        this.last = null;\n    }\n    get closed() {\n        return this.outerObserver.closed;\n    }\n    next(value) {\n        if (this.last === null) {\n            this.last = { value };\n            return this.outerObserver.next(value);\n        }\n        else if (this.compare(this.last.value, value)) {\n            this.last.value = value;\n            return this.outerObserver.next(value);\n        }\n        return Promise.resolve();\n    }\n    complete() {\n        return this.outerObserver.complete();\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"../observable\");\nfunction map(xf) {\n    return function mapI(source) {\n        return new observable_1.Observable(new MapProducer(source, xf));\n    };\n}\nexports.map = map;\nclass MapProducer {\n    constructor(source, xf) {\n        this.source = source;\n        this.xf = xf;\n    }\n    subscribe(observer) {\n        const sub = this.source.subscribe(new MapSourceObserver(this.xf, observer));\n        return new MapCancel(sub);\n    }\n}\nclass MapSourceObserver {\n    constructor(xf, observer) {\n        this.xf = xf;\n        this.observer = observer;\n    }\n    get closed() {\n        return this.observer.closed;\n    }\n    next(value) {\n        const { xf } = this;\n        return this.observer.next(xf(value));\n    }\n    complete() {\n        return this.observer.complete();\n    }\n}\nclass MapCancel {\n    constructor(sub) {\n        this.sub = sub;\n    }\n    cancel() {\n        if (!this.sub.closed) {\n            this.sub.cancel();\n        }\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"../observable\");\nfunction state(initial) {\n    return function stateI(source) {\n        return new State(initial, source);\n    };\n}\nexports.state = state;\nclass State extends observable_1.Observable {\n    constructor(value, source) {\n        const context = {\n            last: value,\n            source,\n            sourceSub: undefined,\n            leeches: []\n        };\n        super(new StateProducer(context));\n        this.context = context;\n    }\n    valueOf() {\n        return this.context.last;\n    }\n    unwrap() {\n        return this.context.last;\n    }\n}\nexports.State = State;\nclass StateProducer {\n    constructor(context) {\n        this.context = context;\n    }\n    subscribe(observer) {\n        const leechContext = {\n            initialValueScheduled: true,\n            observer\n        };\n        if (this.context.leeches == undefined) {\n            this.context.leeches = [];\n        }\n        this.context.leeches.push(leechContext);\n        Promise.resolve({ context: this.context, leechContext }).then(sendInitial);\n        this.context.sourceSub =\n            this.context.sourceSub ||\n                this.context.source.subscribe(new StateSourceObserver(this.context));\n        return new StateCancel(leechContext, this.context);\n    }\n}\nfunction sendInitial({ context, leechContext }) {\n    if (leechContext.initialValueScheduled) {\n        leechContext.initialValueScheduled = false;\n        leechContext.observer.next(context.last);\n    }\n}\nclass StateCancel {\n    constructor(leech, context) {\n        this.leech = leech;\n        this.context = context;\n    }\n    cancel() {\n        if (this.context.leeches != undefined) {\n            const pos = this.context.leeches.indexOf(this.leech);\n            if (pos >= 0) {\n                this.context.leeches.splice(pos, 1);\n                if (this.context.leeches.length === 0) {\n                    const { sourceSub } = this.context;\n                    this.context.sourceSub = undefined;\n                    if (sourceSub && !sourceSub.closed) {\n                        sourceSub.cancel();\n                    }\n                }\n            }\n        }\n    }\n}\nclass StateSourceObserver {\n    constructor(context) {\n        this.context = context;\n    }\n    get closed() {\n        return this.context.leeches.length > 0;\n    }\n    next(value) {\n        this.context.last = value;\n        const deliveries = [];\n        const { leeches } = this.context;\n        if (leeches != undefined) {\n            for (let i = 0, l = leeches.length; i < l; i++) {\n                leeches[i].initialValueScheduled = false;\n                const delivery = leeches[i].observer.next(value);\n                deliveries.push(delivery);\n            }\n        }\n        return deliveries.length ? Promise.all(deliveries) : Promise.resolve();\n    }\n    complete() {\n        const deliveries = [];\n        const { leeches } = this.context;\n        this.context.leeches = [];\n        if (leeches != undefined) {\n            for (let i = 0, l = leeches.length; i < l; i++) {\n                const delivery = leeches[i].observer.complete();\n                deliveries.push(delivery);\n            }\n        }\n        return deliveries.length ? Promise.all(deliveries) : Promise.resolve();\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"../observable\");\nfunction subject(source) {\n    return new observable_1.Observable(new SubjectProducer(source, {\n        observers: [],\n        sourceSub: undefined\n    }));\n}\nexports.subject = subject;\nclass SubjectProducer {\n    constructor(source, context) {\n        this.source = source;\n        this.context = context;\n    }\n    subscribe(observer) {\n        this.context.observers.push(observer);\n        if (!this.context.sourceSub) {\n            this.context.sourceSub = this.source.subscribe(new SubjectSourceObserver(this.context));\n        }\n        return new SubjectCancel(observer, this.context);\n    }\n}\nclass SubjectSourceObserver {\n    constructor(context) {\n        this.context = context;\n    }\n    get closed() {\n        return this.context.observers.length === 0;\n    }\n    next(value) {\n        const deliveries = [];\n        const { observers } = this.context;\n        for (let i = 0, l = observers.length; i < l; i++) {\n            const delivery = observers[i].next(value);\n            deliveries.push(delivery);\n        }\n        return deliveries.length ? Promise.all(deliveries) : Promise.resolve();\n    }\n    complete() {\n        const deliveries = [];\n        this.context.sourceSub = undefined;\n        const observers = this.context.observers.splice(0);\n        for (let i = 0, l = observers.length; i < l; i++) {\n            const delivery = observers[i].complete();\n            deliveries.push(delivery);\n        }\n        return deliveries.length ? Promise.all(deliveries) : Promise.resolve();\n    }\n}\nclass SubjectCancel {\n    constructor(observer, context) {\n        this.observer = observer;\n        this.context = context;\n    }\n    cancel() {\n        const pos = this.context.observers.indexOf(this.observer);\n        if (pos >= 0) {\n            this.context.observers.splice(pos, 1);\n            if (this.context.observers.length === 0 && this.context.sourceSub) {\n                const { sourceSub } = this.context;\n                this.context.sourceSub = undefined;\n                if (!sourceSub.closed) {\n                    sourceSub.cancel();\n                }\n            }\n        }\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst emptyProps = {};\nconst emptyChildren = [];\nfunction element(tagName, desc, children2) {\n    return {\n        tagName,\n        attrs: emptyProps,\n        props: emptyProps,\n        style: emptyProps,\n        events: emptyProps,\n        children: emptyChildren,\n        ...desc,\n        ...(children2 ? { children: children2 } : emptyProps)\n    };\n}\nexports.element = element;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst element_1 = require(\"./element\");\nfunction h(...args) {\n    if (typeof args[0] === \"function\") {\n        const [component, props, ...children] = args;\n        return component(children && children.length ? { ...props, children } : props);\n    }\n    const [tag, desc, ...children] = args;\n    return element_1.element(tag, desc, children && children.length === 1 && typeof children[0] === \"function\"\n        ? children[0]\n        : children);\n}\nexports.h = h;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst element_1 = require(\"./element\");\nfunction bindToTag(tagName) {\n    return (desc, children) => element_1.element(tagName, desc, children);\n}\nvar html;\n(function (html_1) {\n    html_1.a = bindToTag(\"a\");\n    html_1.abbr = bindToTag(\"abbr\");\n    html_1.address = bindToTag(\"address\");\n    html_1.applet = bindToTag(\"applet\");\n    html_1.area = bindToTag(\"area\");\n    html_1.article = bindToTag(\"article\");\n    html_1.aside = bindToTag(\"aside\");\n    html_1.audio = bindToTag(\"audio\");\n    html_1.b = bindToTag(\"b\");\n    html_1.base = bindToTag(\"base\");\n    html_1.basefont = bindToTag(\"basefont\");\n    html_1.bdo = bindToTag(\"bdo\");\n    html_1.blockquote = bindToTag(\"blockquote\");\n    html_1.body = bindToTag(\"body\");\n    html_1.br = bindToTag(\"br\");\n    html_1.button = bindToTag(\"button\");\n    html_1.canvas = bindToTag(\"canvas\");\n    html_1.caption = bindToTag(\"caption\");\n    html_1.cite = bindToTag(\"cite\");\n    html_1.code = bindToTag(\"code\");\n    html_1.col = bindToTag(\"col\");\n    html_1.colgroup = bindToTag(\"colgroup\");\n    html_1.data = bindToTag(\"data\");\n    html_1.datalist = bindToTag(\"datalist\");\n    html_1.dd = bindToTag(\"dd\");\n    html_1.del = bindToTag(\"del\");\n    html_1.details = bindToTag(\"details\");\n    html_1.dfn = bindToTag(\"dfn\");\n    html_1.dialog = bindToTag(\"dialog\");\n    html_1.dir = bindToTag(\"dir\");\n    html_1.div = bindToTag(\"div\");\n    html_1.dl = bindToTag(\"dl\");\n    html_1.dt = bindToTag(\"dt\");\n    html_1.em = bindToTag(\"em\");\n    html_1.embed = bindToTag(\"embed\");\n    html_1.fieldset = bindToTag(\"fieldset\");\n    html_1.figcaption = bindToTag(\"figcaption\");\n    html_1.figure = bindToTag(\"figure\");\n    html_1.font = bindToTag(\"font\");\n    html_1.footer = bindToTag(\"footer\");\n    html_1.form = bindToTag(\"form\");\n    html_1.frame = bindToTag(\"frame\");\n    html_1.frameset = bindToTag(\"frameset\");\n    html_1.h1 = bindToTag(\"h1\");\n    html_1.h2 = bindToTag(\"h2\");\n    html_1.h3 = bindToTag(\"h3\");\n    html_1.h4 = bindToTag(\"h4\");\n    html_1.h5 = bindToTag(\"h5\");\n    html_1.h6 = bindToTag(\"h6\");\n    html_1.head = bindToTag(\"head\");\n    html_1.header = bindToTag(\"header\");\n    html_1.hgroup = bindToTag(\"hgroup\");\n    html_1.hr = bindToTag(\"hr\");\n    html_1.html = bindToTag(\"html\");\n    html_1.i = bindToTag(\"i\");\n    html_1.iframe = bindToTag(\"iframe\");\n    html_1.img = bindToTag(\"img\");\n    html_1.input = bindToTag(\"input\");\n    html_1.ins = bindToTag(\"ins\");\n    html_1.kbd = bindToTag(\"kbd\");\n    html_1.label = bindToTag(\"label\");\n    html_1.legend = bindToTag(\"legend\");\n    html_1.li = bindToTag(\"li\");\n    html_1.link = bindToTag(\"link\");\n    html_1.map = bindToTag(\"map\");\n    html_1.mark = bindToTag(\"mark\");\n    html_1.marquee = bindToTag(\"marquee\");\n    html_1.menu = bindToTag(\"menu\");\n    html_1.meta = bindToTag(\"meta\");\n    html_1.meter = bindToTag(\"meter\");\n    html_1.nav = bindToTag(\"nav\");\n    html_1.noscript = bindToTag(\"noscript\");\n    html_1.object = bindToTag(\"object\");\n    html_1.ol = bindToTag(\"ol\");\n    html_1.optgroup = bindToTag(\"optgroup\");\n    html_1.option = bindToTag(\"option\");\n    html_1.output = bindToTag(\"output\");\n    html_1.p = bindToTag(\"p\");\n    html_1.param = bindToTag(\"param\");\n    html_1.picture = bindToTag(\"picture\");\n    html_1.pre = bindToTag(\"pre\");\n    html_1.progress = bindToTag(\"progress\");\n    html_1.q = bindToTag(\"q\");\n    html_1.rt = bindToTag(\"rt\");\n    html_1.ruby = bindToTag(\"ruby\");\n    html_1.s = bindToTag(\"s\");\n    html_1.samp = bindToTag(\"samp\");\n    html_1.script = bindToTag(\"script\");\n    html_1.section = bindToTag(\"section\");\n    html_1.select = bindToTag(\"select\");\n    html_1.slot = bindToTag(\"slot\");\n    html_1.small = bindToTag(\"small\");\n    html_1.source = bindToTag(\"source\");\n    html_1.span = bindToTag(\"span\");\n    html_1.strong = bindToTag(\"strong\");\n    html_1.style = bindToTag(\"style\");\n    html_1.sub = bindToTag(\"sub\");\n    html_1.sup = bindToTag(\"sup\");\n    html_1.table = bindToTag(\"table\");\n    html_1.tbody = bindToTag(\"tbody\");\n    html_1.td = bindToTag(\"td\");\n    html_1.template = bindToTag(\"template\");\n    html_1.textarea = bindToTag(\"textarea\");\n    html_1.tfoot = bindToTag(\"tfoot\");\n    html_1.th = bindToTag(\"th\");\n    html_1.thead = bindToTag(\"thead\");\n    html_1.time = bindToTag(\"time\");\n    html_1.title = bindToTag(\"title\");\n    html_1.tr = bindToTag(\"tr\");\n    html_1.track = bindToTag(\"track\");\n    html_1.u = bindToTag(\"u\");\n    html_1.ul = bindToTag(\"ul\");\n    html_1.variable = bindToTag(\"var\");\n    html_1.video = bindToTag(\"video\");\n    html_1.wbr = bindToTag(\"wbr\");\n})(html = exports.html || (exports.html = {}));\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./element\"));\n__export(require(\"./h\"));\n__export(require(\"./html\"));\n__export(require(\"./mount\"));\n__export(require(\"./render\"));\n__export(require(\"./svg\"));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst render_1 = require(\"./render\");\nfunction mount(mount, app) {\n    const { element, possesion } = render_1.render(app);\n    mount.appendChild(element);\n    return () => {\n        mount.removeChild(element);\n        possesion.clean(element, true);\n    };\n}\nexports.mount = mount;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"@hullo/core/observable\");\nconst NO_POSSESSION = {\n    clean() { }\n};\nfunction render(shape) {\n    const e = document.createElement(shape.tagName);\n    return { element: e, possesion: mold(e, shape) };\n}\nexports.render = render;\nfunction render_internal(shape, inheritedSync) {\n    const e = document.createElement(shape.tagName);\n    return { element: e, possesion: mold(e, shape, inheritedSync) };\n}\nfunction mold(htmlElement, elementShape, inheritedSync) {\n    const { attrs, props, events, style, children } = elementShape;\n    const syncOptions = elementShape.sync || inheritedSync || \"immediate\";\n    const possesions = new Array();\n    for (const k in attrs) {\n        if (!Object.prototype.hasOwnProperty.call(attrs, k)) {\n            continue;\n        }\n        possesions.push(render_attr(htmlElement, syncOptions, k, attrs[k]));\n    }\n    for (const k in props) {\n        if (!Object.prototype.hasOwnProperty.call(props, k)) {\n            continue;\n        }\n        possesions.push(render_prop(htmlElement, syncOptions, k, props[k]));\n    }\n    for (const k in events) {\n        if (!Object.prototype.hasOwnProperty.call(events, k)) {\n            continue;\n        }\n        const handler = events[k];\n        possesions.push(typeof handler === \"function\"\n            ? render_event_regular(htmlElement, k, handler)\n            : render_event_observer(htmlElement, k, handler));\n    }\n    for (const k in style) {\n        if (!Object.prototype.hasOwnProperty.call(style, k)) {\n            continue;\n        }\n        possesions.push(render_style(htmlElement, syncOptions, k, style[k]));\n    }\n    possesions.push(render_children(htmlElement, syncOptions, children));\n    if (elementShape.ref) {\n        elementShape.ref(htmlElement);\n    }\n    if (elementShape.deref) {\n        possesions.push(new DerefPossesion(elementShape));\n    }\n    return new JoinedPossesions(possesions);\n}\nexports.mold = mold;\nclass JoinedPossesions {\n    constructor(possesions) {\n        this.possesions = possesions;\n    }\n    clean(htmlElement, abandonment) {\n        for (let i = 0; i < this.possesions.length; i++) {\n            this.possesions[i].clean(htmlElement, abandonment);\n        }\n    }\n}\nclass DerefPossesion {\n    constructor(shape) {\n        this.shape = shape;\n    }\n    clean(htmlElement, _abandonment) {\n        this.shape.deref(htmlElement);\n    }\n}\nfunction render_children(htmlElement, syncOptions, childShapes$) {\n    const children = {\n        shapes: [],\n        elements: [],\n        possesions: []\n    };\n    return render_each(htmlElement, syncOptions, childShapes$, children, render_children_each, render_children_cleanup);\n}\nfunction render_children_each(htmlElement, syncOptions, nextShapes, children) {\n    const { shapes, elements, possesions } = children;\n    const nextElements = [];\n    const nextPossesions = [];\n    for (let i = 0; i < Math.max(shapes.length, nextShapes.length); i++) {\n        const currentShape = shapes[i];\n        const currentElement = elements[i];\n        const currentPossesion = possesions[i];\n        const nextShape = nextShapes[i];\n        let nextShapePrevPos = -1;\n        // element stays on position\n        if (i < shapes.length &&\n            i < nextShapes.length &&\n            currentShape === nextShape) {\n            nextElements.push(elements[i]);\n            nextPossesions.push(possesions[i]);\n        }\n        // element exists and should be moved\n        else if (i < nextShapes.length &&\n            (nextShapePrevPos = shapes.indexOf(nextShape)) >= 0 &&\n            nextShapes.indexOf(nextShape) === i) {\n            nextElements.push(elements[nextShapePrevPos]);\n            nextPossesions.push(possesions[nextShapePrevPos]);\n        }\n        //element remains\n        else if (i < shapes.length && i < nextShapes.length) {\n            const abandon = typeof currentShape === \"string\" ||\n                typeof nextShape === \"string\" ||\n                currentShape.tagName !== nextShape.tagName;\n            if (typeof currentShape === \"object\") {\n                currentPossesion.clean(currentElement, abandon);\n            }\n            const { element, possesion } = typeof nextShape === \"string\"\n                ? {\n                    element: document.createTextNode(nextShape),\n                    possesion: NO_POSSESSION\n                }\n                : abandon\n                    ? render_internal(nextShape, syncOptions)\n                    : {\n                        element: currentElement,\n                        possesion: mold(currentElement, nextShape, syncOptions)\n                    };\n            nextElements.push(element);\n            nextPossesions.push(possesion);\n        }\n        // element adding\n        else if (i < nextShapes.length) {\n            if (typeof nextShape === \"string\") {\n                nextElements.push(document.createTextNode(nextShape));\n                nextPossesions.push(NO_POSSESSION);\n            }\n            else {\n                const { element, possesion } = render_internal(nextShape, syncOptions);\n                nextElements.push(element);\n                nextPossesions.push(possesion);\n            }\n        }\n    }\n    // diff\n    let currVec = 0;\n    let nextVec = 0;\n    while (currVec < elements.length && nextVec < nextElements.length) {\n        const currLen = elements.length;\n        const nextLen = nextElements.length;\n        const currElem = elements[currVec];\n        const nextElem = nextElements[nextVec];\n        if (currElem === nextElem) {\n            currVec++;\n            nextVec++;\n            continue;\n        }\n        const currElementAtNext = nextElements.indexOf(currElem, nextVec);\n        if (currElementAtNext < 0) {\n            htmlElement.removeChild(currElem);\n            currVec++;\n            continue;\n        }\n        const nextElementAtCurr = elements.indexOf(nextElem, currVec);\n        if (nextElementAtCurr < 0) {\n            if (currVec < currLen) {\n                htmlElement.insertBefore(nextElem, elements[currVec]);\n            }\n            else {\n                htmlElement.appendChild(nextElem);\n            }\n            nextVec++;\n            continue;\n        }\n        let fromCurrVecStableLen = 0;\n        for (let distance = 0, max = Math.min(nextLen - currElementAtNext, currLen - currVec); distance < max; distance++) {\n            if (elements[currVec + distance] ===\n                nextElements[currElementAtNext + distance]) {\n                fromCurrVecStableLen++;\n            }\n            else {\n                break;\n            }\n        }\n        let leftStaysBenefit = fromCurrVecStableLen - (currElementAtNext - nextVec);\n        let fromNextVecStableLen = 0;\n        for (let distance = 0, max = Math.min(currLen - nextElementAtCurr, nextLen - nextVec); distance < max; distance++) {\n            if (elements[nextVec + distance] ===\n                nextElements[nextElementAtCurr + distance]) {\n                fromNextVecStableLen++;\n            }\n            else {\n                break;\n            }\n        }\n        let rightStaysBenefit = fromNextVecStableLen - (nextElementAtCurr - currVec);\n        if (leftStaysBenefit > rightStaysBenefit && rightStaysBenefit > 0) {\n            for (let i = nextVec; i < currElementAtNext; i++) {\n                htmlElement.insertBefore(nextElements[i], currElem);\n            }\n            nextVec += currElementAtNext - nextVec;\n            currVec += fromCurrVecStableLen;\n            nextVec += fromCurrVecStableLen;\n        }\n        else if (rightStaysBenefit >= leftStaysBenefit && leftStaysBenefit > 0) {\n            for (let i = currVec; i < nextElementAtCurr; i++) {\n                htmlElement.removeChild(elements[i]);\n            }\n            currVec += nextElementAtCurr - currVec;\n            currVec += fromNextVecStableLen;\n            nextVec += fromNextVecStableLen;\n        }\n        else {\n            htmlElement.replaceChild(nextElem, currElem);\n            currVec++;\n            nextVec++;\n            elements.splice(nextElementAtCurr, 1);\n            shapes.splice(nextElementAtCurr, 1);\n            possesions.splice(nextElementAtCurr, 1);\n        }\n    }\n    for (let i = currVec; i < elements.length; i++) {\n        htmlElement.removeChild(elements[i]);\n    }\n    for (let i = nextVec; i < nextElements.length; i++) {\n        htmlElement.appendChild(nextElements[i]);\n    }\n    children.shapes = nextShapes;\n    children.elements = nextElements;\n    children.possesions = nextPossesions;\n}\nfunction render_children_cleanup(htmlElement, _syncOptions, _children) {\n    for (let i = 0, l = htmlElement.children.length; i < l; i++) {\n        htmlElement.removeChild(htmlElement.firstChild);\n    }\n}\nfunction render_event_regular(htmlElement, name, handler) {\n    htmlElement.addEventListener(name, handler);\n    return {\n        clean: function cancelEventListenerApplication() {\n            htmlElement.removeEventListener(name, handler);\n        }\n    };\n}\nfunction render_event_observer(htmlElement, name, handler) {\n    const observer = handler;\n    let closed = false;\n    htmlElement.addEventListener(name, render_event_observer_listener);\n    return {\n        clean: render_event_observer_cancel\n    };\n    function render_event_observer_cancel() {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        htmlElement.removeEventListener(name, render_event_observer_listener);\n        observer.complete();\n    }\n    function render_event_observer_listener(event) {\n        if (closed) {\n            return;\n        }\n        observer.next(event);\n    }\n}\nfunction render_prop(htmlElement, syncOptions, name, value) {\n    const hasDefaultValue = name in htmlElement;\n    const defaultValue = hasDefaultValue ? htmlElement[name] : undefined;\n    const state = {\n        name,\n        hasDefaultValue,\n        defaultValue,\n        lastValue: defaultValue\n    };\n    return render_each(htmlElement, syncOptions, value, state, render_prop_each, render_prop_cleanup);\n}\nfunction render_prop_each(htmlElement, _syncOptions, value, state) {\n    if (value !== state.lastValue) {\n        state.lastValue = value;\n        htmlElement[state.name] = value;\n    }\n}\nfunction render_prop_cleanup(htmlElement, _syncOptions, state) {\n    if (state.hasDefaultValue) {\n        if (state.defaultValue !== state.lastValue) {\n            htmlElement[state.name] = state.defaultValue;\n        }\n    }\n    else {\n        if (name in htmlElement) {\n            delete htmlElement[state.name];\n        }\n    }\n}\nfunction render_style(htmlElement, syncOptions, name, value) {\n    const defaultValue = htmlElement.style[name];\n    const state = {\n        name,\n        defaultValue,\n        lastValue: defaultValue\n    };\n    return render_each(htmlElement, syncOptions, value, state, render_style_each, render_style_cleanup);\n}\nfunction render_style_each(htmlElement, _syncOptions, value, state) {\n    if (value !== state.lastValue) {\n        state.lastValue = value;\n        htmlElement.style[state.name] = value;\n    }\n}\nfunction render_style_cleanup(htmlElement, _syncOptions, state) {\n    if (state.defaultValue !== state.lastValue) {\n        htmlElement.style[state.name] = state.defaultValue;\n    }\n}\nfunction render_attr(htmlElement, syncOptions, name, value) {\n    const defaultValue = htmlElement.getAttribute(name);\n    return render_each(htmlElement, syncOptions, value, { name, defaultValue, lastValue: defaultValue }, render_attr_each, render_attr_cleanup);\n}\nfunction render_attr_each(htmlElement, _syncOptions, value, state) {\n    if (value !== state.lastValue) {\n        state.lastValue = value;\n        if (value == null) {\n            htmlElement.removeAttribute(state.name);\n        }\n        else {\n            htmlElement.setAttribute(state.name, value);\n        }\n    }\n}\nfunction render_attr_cleanup(htmlElement, _syncOptions, state) {\n    if (state.defaultValue !== state.lastValue) {\n        if (state.defaultValue == null) {\n            htmlElement.removeAttribute(state.name);\n        }\n        else {\n            htmlElement.setAttribute(state.name, state.defaultValue);\n        }\n    }\n}\nfunction render_each(htmlElement, syncMode, streamOrValue, state, process, cleanup) {\n    if (observable_1.Observable.isObservable(streamOrValue)) {\n        const isClosed = { ref: false };\n        return new RenderEachStreamPossesions(isClosed, cleanup, streamOrValue.subscribe(new RenderEachObserver(isClosed, htmlElement, syncMode, state, process)), syncMode, state);\n    }\n    else {\n        process(htmlElement, syncMode, streamOrValue, state);\n        return new RenderEachPossesions(cleanup, syncMode, state);\n    }\n}\nclass RenderEachObserver {\n    constructor(isClosed, htmlElement, syncMode, state, process) {\n        this.isClosed = isClosed;\n        this.htmlElement = htmlElement;\n        this.syncMode = syncMode;\n        this.state = state;\n        this.process = process;\n    }\n    get closed() {\n        return this.isClosed.ref;\n    }\n    next(singleValue) {\n        this.process(this.htmlElement, this.syncMode, singleValue, this.state);\n        if (this.syncMode !== \"immediate\") {\n            return whenPainted();\n        }\n        return Promise.resolve();\n    }\n    complete() {\n        return Promise.resolve();\n    }\n}\nclass RenderEachStreamPossesions {\n    constructor(isClosed, cleanup, subscription, syncMode, state) {\n        this.isClosed = isClosed;\n        this.cleanup = cleanup;\n        this.subscription = subscription;\n        this.syncMode = syncMode;\n        this.state = state;\n    }\n    clean(htmlElement, abandonment) {\n        this.isClosed.ref = true;\n        if (!abandonment) {\n            this.cleanup(htmlElement, this.syncMode, this.state);\n        }\n        if (this.subscription && !this.subscription.closed) {\n            this.subscription.cancel();\n        }\n    }\n}\nclass RenderEachPossesions {\n    constructor(cleanup, syncMode, state) {\n        this.cleanup = cleanup;\n        this.syncMode = syncMode;\n        this.state = state;\n    }\n    clean(htmlElement, abandonment) {\n        if (!abandonment) {\n            this.cleanup(htmlElement, this.syncMode, this.state);\n        }\n    }\n}\n// paint sync\nlet resolveWhenPainted = null;\nlet whenPaintedTask = null;\nconst whenPainted = typeof window === \"undefined\" || !(\"requestAnimationFrame\" in window)\n    ? function getWhenPainted() {\n        return (whenPaintedTask ||\n            (whenPaintedTask = new Promise(whenPainter_timeout)));\n    }\n    : function getWhenPainted() {\n        return (whenPaintedTask ||\n            (whenPaintedTask = new Promise(whenPainted_raf)));\n    };\nfunction whenPainter_timeout(resolve) {\n    setTimeout(flushWhenPaintedCbs, 0);\n    resolveWhenPainted = resolve;\n}\nfunction whenPainted_raf(resolve) {\n    window.requestAnimationFrame(flushWhenPaintedCbs);\n    resolveWhenPainted = resolve;\n}\nfunction flushWhenPaintedCbs() {\n    whenPaintedTask = null;\n    if (resolveWhenPainted) {\n        const _whenPaintedConsumer = resolveWhenPainted;\n        resolveWhenPainted = null;\n        _whenPaintedConsumer();\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst element_1 = require(\"./element\");\nfunction bindToTag(tagName) {\n    return (desc, children) => element_1.element(tagName, desc, children);\n}\nvar svg;\n(function (svg_1) {\n    svg_1.a = bindToTag(\"a\");\n    svg_1.altGlyph = bindToTag(\"altGlyph\");\n    svg_1.altGlyphDef = bindToTag(\"altGlyphDef\");\n    svg_1.altGlyphItem = bindToTag(\"altGlyphItem\");\n    svg_1.animate = bindToTag(\"animate\");\n    svg_1.animateColor = bindToTag(\"animateColor\");\n    svg_1.animateMotion = bindToTag(\"animateMotion\");\n    svg_1.animateTransform = bindToTag(\"animateTransform\");\n    svg_1.audio = bindToTag(\"audio\");\n    svg_1.canvas = bindToTag(\"canvas\");\n    svg_1.circle = bindToTag(\"circle\");\n    svg_1.clipPath = bindToTag(\"clipPath\");\n    svg_1.colorProfile = bindToTag(\"color-profile\");\n    svg_1.cursor = bindToTag(\"cursor\");\n    svg_1.defs = bindToTag(\"defs\");\n    svg_1.desc = bindToTag(\"desc\");\n    svg_1.discard = bindToTag(\"discard\");\n    svg_1.ellipse = bindToTag(\"ellipse\");\n    svg_1.feBlend = bindToTag(\"feBlend\");\n    svg_1.feColorMatrix = bindToTag(\"feColorMatrix\");\n    svg_1.feComponentTransfer = bindToTag(\"feComponentTransfer\");\n    svg_1.feComposite = bindToTag(\"feComposite\");\n    svg_1.feConvolveMatrix = bindToTag(\"feConvolveMatrix\");\n    svg_1.feDiffuseLighting = bindToTag(\"feDiffuseLighting\");\n    svg_1.feDisplacementMap = bindToTag(\"feDisplacementMap\");\n    svg_1.feDistantLight = bindToTag(\"feDistantLight\");\n    svg_1.feDropShadow = bindToTag(\"feDropShadow\");\n    svg_1.feFlood = bindToTag(\"feFlood\");\n    svg_1.feFuncA = bindToTag(\"feFuncA\");\n    svg_1.feFuncB = bindToTag(\"feFuncB\");\n    svg_1.feFuncG = bindToTag(\"feFuncG\");\n    svg_1.feFuncR = bindToTag(\"feFuncR\");\n    svg_1.feGaussianBlur = bindToTag(\"feGaussianBlur\");\n    svg_1.feImage = bindToTag(\"feImage\");\n    svg_1.feMerge = bindToTag(\"feMerge\");\n    svg_1.feMergeNode = bindToTag(\"feMergeNode\");\n    svg_1.feMorphology = bindToTag(\"feMorphology\");\n    svg_1.feOffset = bindToTag(\"feOffset\");\n    svg_1.fePointLight = bindToTag(\"fePointLight\");\n    svg_1.feSpecularLighting = bindToTag(\"feSpecularLighting\");\n    svg_1.feSpotLight = bindToTag(\"feSpotLight\");\n    svg_1.feTile = bindToTag(\"feTile\");\n    svg_1.feTurbulence = bindToTag(\"feTurbulence\");\n    svg_1.filter = bindToTag(\"filter\");\n    svg_1.font = bindToTag(\"font\");\n    svg_1.fontFace = bindToTag(\"font-face\");\n    svg_1.fontFaceFormat = bindToTag(\"font-face-format\");\n    svg_1.fontFaceName = bindToTag(\"font-face-name\");\n    svg_1.fontFaceSrc = bindToTag(\"font-face-src\");\n    svg_1.fontFaceUri = bindToTag(\"font-face-uri\");\n    svg_1.foreignObject = bindToTag(\"foreignObject\");\n    svg_1.g = bindToTag(\"g\");\n    svg_1.glyph = bindToTag(\"glyph\");\n    svg_1.glyphRef = bindToTag(\"glyphRef\");\n    svg_1.hatch = bindToTag(\"hatch\");\n    svg_1.hatchpath = bindToTag(\"hatchpath\");\n    svg_1.hkern = bindToTag(\"hkern\");\n    svg_1.iframe = bindToTag(\"iframe\");\n    svg_1.image = bindToTag(\"image\");\n    svg_1.line = bindToTag(\"line\");\n    svg_1.linearGradient = bindToTag(\"linearGradient\");\n    svg_1.marker = bindToTag(\"marker\");\n    svg_1.mask = bindToTag(\"mask\");\n    svg_1.mesh = bindToTag(\"mesh\");\n    svg_1.meshgradient = bindToTag(\"meshgradient\");\n    svg_1.meshpatch = bindToTag(\"meshpatch\");\n    svg_1.meshrow = bindToTag(\"meshrow\");\n    svg_1.metadata = bindToTag(\"metadata\");\n    svg_1.missingGlyph = bindToTag(\"missing-glyph\");\n    svg_1.mpath = bindToTag(\"mpath\");\n    svg_1.path = bindToTag(\"path\");\n    svg_1.pattern = bindToTag(\"pattern\");\n    svg_1.polygon = bindToTag(\"polygon\");\n    svg_1.polyline = bindToTag(\"polyline\");\n    svg_1.radialGradient = bindToTag(\"radialGradient\");\n    svg_1.rect = bindToTag(\"rect\");\n    svg_1.script = bindToTag(\"script\");\n    svg_1.set = bindToTag(\"set\");\n    svg_1.solidcolor = bindToTag(\"solidcolor\");\n    svg_1.stop = bindToTag(\"stop\");\n    svg_1.style = bindToTag(\"style\");\n    svg_1.svg = bindToTag(\"svg\");\n    svg_1.switchElement = bindToTag(\"switch\");\n    svg_1.symbol = bindToTag(\"symbol\");\n    svg_1.text = bindToTag(\"text\");\n    svg_1.textPath = bindToTag(\"textPath\");\n    svg_1.title = bindToTag(\"title\");\n    svg_1.tref = bindToTag(\"tref\");\n    svg_1.tspan = bindToTag(\"tspan\");\n    svg_1.unknown = bindToTag(\"unknown\");\n    svg_1.use = bindToTag(\"use\");\n    svg_1.video = bindToTag(\"video\");\n    svg_1.view = bindToTag(\"view\");\n    svg_1.vkern = bindToTag(\"vkern\");\n})(svg = exports.svg || (exports.svg = {}));\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport resolvePathname from 'resolve-pathname';\nimport valueEqual from 'value-equal';\nimport warning from 'tiny-warning';\nimport invariant from 'tiny-invariant';\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n}\nfunction stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n  return new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path);\n}\nfunction stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n  var hashIndex = pathname.indexOf('#');\n\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n}\nfunction createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n  var path = pathname || '/';\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : \"?\" + search;\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : \"#\" + hash;\n  return path;\n}\n\nfunction createLocation(path, state, key, currentLocation) {\n  var location;\n\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n}\nfunction locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n}\n\nfunction createTransitionManager() {\n  var prompt = null;\n\n  function setPrompt(nextPrompt) {\n    process.env.NODE_ENV !== \"production\" ? warning(prompt == null, 'A history supports only one prompt at a time') : void 0;\n    prompt = nextPrompt;\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  }\n\n  function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : void 0;\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  }\n\n  var listeners = [];\n\n  function appendListener(fn) {\n    var isActive = true;\n\n    function listener() {\n      if (isActive) fn.apply(void 0, arguments);\n    }\n\n    listeners.push(listener);\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  }\n\n  function notifyListeners() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(void 0, args);\n    });\n  }\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\nfunction getConfirmation(message, callback) {\n  callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\n\nfunction supportsHistory() {\n  var ua = window.navigator.userAgent;\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n  return window.history && 'pushState' in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\n\nfunction supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\n\nfunction supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\n\nfunction isExtraneousPopstateEvent(event) {\n  event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n}\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nfunction getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\n\n\nfunction createBrowserHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Browser history needs a DOM') : invariant(false) : void 0;\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n  var _props = props,\n      _props$forceRefresh = _props.forceRefresh,\n      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var path = pathname + search + hash;\n    process.env.NODE_ENV !== \"production\" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path, state, key);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n    handlePop(getDOMLocation(event.state));\n  }\n\n  function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  }\n\n  var forceNextPop = false;\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  }\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key]; // Public interface\n\n  function createHref(location) {\n    return basename + createPath(location);\n  }\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.pushState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history') : void 0;\n        window.location.href = href;\n      }\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.replaceState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history') : void 0;\n        window.location.replace(href);\n      }\n    });\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nvar HashChangeEvent$1 = 'hashchange';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nfunction getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n}\n\nfunction pushHashPath(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n}\n\nfunction createHashHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Hash history needs a DOM') : invariant(false) : void 0;\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props = props,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = _props.hashType,\n      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n  function getDOMLocation() {\n    var path = decodePath(getHashPath());\n    process.env.NODE_ENV !== \"production\" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  }\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  } // Ensure the hash is encoded properly before doing anything else.\n\n\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)]; // Public interface\n\n  function createHref(location) {\n    return '#' + encodePath(basename + createPath(location));\n  }\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Hash history cannot push state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack') : void 0;\n        setState();\n      }\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Hash history cannot replace state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    process.env.NODE_ENV !== \"production\" ? warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(HashChangeEvent$1, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(HashChangeEvent$1, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */\n\n\nfunction createMemoryHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      getUserConfirmation = _props.getUserConfirmation,\n      _props$initialEntries = _props.initialEntries,\n      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,\n      _props$initialIndex = _props.initialIndex,\n      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\n  }); // Public interface\n\n  var createHref = createPath;\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n      var nextEntries = history.entries.slice(0);\n\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      history.entries[history.index] = location;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  }\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    return transitionManager.setPrompt(prompt);\n  }\n\n  function listen(listener) {\n    return transitionManager.appendListener(listener);\n  }\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nexport { createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath };\n","function isAbsolute(pathname) {\n  return pathname.charAt(0) === '/';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node's url.parse\nfunction resolvePathname(to) {\n  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var toParts = to && to.split('/') || [];\n  var fromParts = from && from.split('/') || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return '/';\n\n  var hasTrailingSlash = void 0;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === '.' || last === '..' || last === '';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === '.') {\n      spliceOne(fromParts, i);\n    } else if (part === '..') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) {\n    fromParts.unshift('..');\n  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');\n\n  var result = fromParts.join('/');\n\n  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';\n\n  return result;\n}\n\nexport default resolvePathname;","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\nexport default invariant;\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction valueEqual(a, b) {\n  if (a === b) return true;\n\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return valueEqual(item, b[index]);\n    });\n  }\n\n  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);\n  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);\n\n  if (aType !== bType) return false;\n\n  if (aType === 'object') {\n    var aValue = a.valueOf();\n    var bValue = b.valueOf();\n\n    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);\n\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) return false;\n\n    return aKeys.every(function (key) {\n      return valueEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\nexport default valueEqual;","import { Channel } from \"@hullo/core/channel\";\nimport { Atom } from \"@hullo/core/atom\";\nimport { map } from \"@hullo/core/operators/map\";\nimport { html } from \"@hullo/dom/html\";\n\nexport function Adder(props: { onAdd: (text: string) => any }) {\n\tconst onInput = new Channel<Event>();\n\tconst newTask = new Atom(\"\");\n\tonInput\n\t\t.pipe(map(event => (event.target as HTMLInputElement).value))\n\t\t.subscribe(newTask);\n\n\treturn html.header({ attrs: { class: \"header\" } }, [\n\t\thtml.h1({ props: { innerText: \"todos\" } }),\n\t\thtml.input({\n\t\t\tattrs: {\n\t\t\t\tclass: \"new-todo\",\n\t\t\t\tautofocus: \"autofocus\",\n\t\t\t\tautocomplete: \"off\",\n\t\t\t\tplaceholder: \"What needs to be done?\"\n\t\t\t},\n\t\t\tprops: { value: newTask },\n\t\t\tevents: {\n\t\t\t\tinput: onInput,\n\t\t\t\tkeydown: event => {\n\t\t\t\t\tif (event instanceof KeyboardEvent && event.keyCode === 13) {\n\t\t\t\t\t\tprops.onAdd(newTask.unwrap());\n\t\t\t\t\t\tnewTask.next(\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t]);\n}\n","import { createHashHistory } from \"history\";\nimport { route } from \"@hullo/browser/route\";\nimport { ofHistory } from \"@hullo/browser/ofHistory\";\nimport { Atom } from \"@hullo/core/atom\";\nimport { combineLatest } from \"@hullo/core/combineLatest\";\nimport { map } from \"@hullo/core/operators/map\";\nimport { state } from \"@hullo/core/operators/state\";\nimport { html } from \"@hullo/dom/html\";\nimport { Task } from \"./Task\";\nimport { filters } from \"./filters\";\nimport { Adder } from \"./Adder\";\nimport { Main } from \"./Main\";\nimport { Footer } from \"./Footer\";\n\nexport function App() {\n\tconst tasksSerialized = window.localStorage.getItem(\"todos-hullo\");\n\tconst tasks$ = new Atom<Task[]>(\n\t\ttasksSerialized ? JSON.parse(tasksSerialized) : []\n\t);\n\ttasks$.subscribe({\n\t\tnext(tasks) {\n\t\t\twindow.localStorage.setItem(\"todos-hullo\", JSON.stringify(tasks));\n\t\t}\n\t});\n\n\tconst selectedFilter$ = ofHistory(createHashHistory())\n\t\t.pipe(\n\t\t\troute([\n\t\t\t\t{\n\t\t\t\t\twhen: /^\\/([a-z]*)$/,\n\t\t\t\t\thave([filter]) {\n\t\t\t\t\t\treturn (filter in filters ? filter : \"all\") as keyof typeof filters;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t])\n\t\t)\n\t\t.pipe(state<keyof typeof filters>(\"all\"));\n\n\tconst selectedTasks$ = combineLatest<[Task[], keyof typeof filters]>([\n\t\ttasks$,\n\t\tselectedFilter$\n\t]).pipe(map(([tasks, selectedFilter]) => filters[selectedFilter](tasks)));\n\n\treturn html.section(\n\t\t{\n\t\t\tattrs: { class: \"todoapp\" }\n\t\t},\n\t\t[\n\t\t\tAdder({\n\t\t\t\tasync onAdd(label) {\n\t\t\t\t\tawait tasks$.update(tasks =>\n\t\t\t\t\t\ttasks.concat([\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlabel,\n\t\t\t\t\t\t\t\tcompleted: selectedFilter$.unwrap() === \"completed\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t])\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}),\n\t\t\tMain({\n\t\t\t\ttasks$,\n\t\t\t\tselectedTasks$,\n\t\t\t\tasync onToggle(idx: number) {\n\t\t\t\t\tawait tasks$.update(tasks =>\n\t\t\t\t\t\ttasks.map((task, i) =>\n\t\t\t\t\t\t\ti === idx ? { ...task, completed: !task.completed } : task\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tasync onRemove(idx: number) {\n\t\t\t\t\tawait tasks$.update(tasks => tasks.filter((_tasks, i) => i !== idx));\n\t\t\t\t},\n\t\t\t\tasync onRename(idx: number, label: string) {\n\t\t\t\t\tawait tasks$.update(tasks =>\n\t\t\t\t\t\ttasks.map((task, i) => (i === idx ? { ...task, label } : task))\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tasync onToggleAll() {\n\t\t\t\t\tconst tasks = tasks$.unwrap();\n\t\t\t\t\tconst completed = filters.active(tasks).length > 0;\n\t\t\t\t\tawait tasks$.update(tasks =>\n\t\t\t\t\t\ttasks.map(({ label }) => ({ label, completed }))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}),\n\t\t\tFooter({\n\t\t\t\ttasks$,\n\t\t\t\tselectedFilter$,\n\t\t\t\tasync clearCompleted() {\n\t\t\t\t\tawait tasks$.update(tasks => tasks.filter(task => !task.completed));\n\t\t\t\t}\n\t\t\t})\n\t\t]\n\t);\n}\n","import { html } from \"@hullo/dom/html\";\nimport { Observable } from \"@hullo/core/observable\";\nimport { map } from \"@hullo/core/operators/map\";\nimport { filters } from \"./filters\";\nimport { Task } from \"./Task\";\nimport { distinctStrictEqual } from \"@hullo/core/operators/distinct\";\n\nexport function Footer(props: {\n\ttasks$: Observable<Task[]>;\n\tselectedFilter$: Observable<\"all\" | \"active\" | \"completed\">;\n\tclearCompleted: () => any;\n}) {\n\treturn html.footer(\n\t\t{\n\t\t\tattrs: {\n\t\t\t\tclass: \"footer\",\n\t\t\t\thidden: props.tasks$\n\t\t\t\t\t.pipe(map(tasks => (tasks.length === 0 ? \"hidden\" : undefined)))\n\t\t\t\t\t.pipe(distinctStrictEqual)\n\t\t\t}\n\t\t},\n\t\t[\n\t\t\thtml.span(\n\t\t\t\t{ attrs: { class: \"todo-count\" } },\n\t\t\t\tprops.tasks$.pipe(\n\t\t\t\t\tmap(tasks => [\n\t\t\t\t\t\thtml.strong({\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tinnerText: props.tasks$.pipe(\n\t\t\t\t\t\t\t\t\tmap(tasks => filters.active(tasks).length.toString())\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t` ${filters.active(tasks).length === 1 ? \"item\" : \"items\"} left`\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t),\n\n\t\t\thtml.ul({ attrs: { class: \"filters\" } }, [\n\t\t\t\thtml.li({}, [\n\t\t\t\t\thtml.a({\n\t\t\t\t\t\tattrs: {\n\t\t\t\t\t\t\thref: \"/#all\",\n\t\t\t\t\t\t\tclass: props.selectedFilter$.pipe(\n\t\t\t\t\t\t\t\tmap(filter => (filter === \"all\" ? \"selected\" : \"\"))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprops: { innerText: \"All\" }\n\t\t\t\t\t})\n\t\t\t\t]),\n\n\t\t\t\thtml.li({}, [\n\t\t\t\t\thtml.a({\n\t\t\t\t\t\tattrs: {\n\t\t\t\t\t\t\thref: \"/#active\",\n\t\t\t\t\t\t\tclass: props.selectedFilter$.pipe(\n\t\t\t\t\t\t\t\tmap(filter => (filter === \"active\" ? \"selected\" : \"\"))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprops: { innerText: \"Active\" }\n\t\t\t\t\t})\n\t\t\t\t]),\n\n\t\t\t\thtml.li({}, [\n\t\t\t\t\thtml.a({\n\t\t\t\t\t\tattrs: {\n\t\t\t\t\t\t\thref: \"/#completed\",\n\t\t\t\t\t\t\tclass: props.selectedFilter$.pipe(\n\t\t\t\t\t\t\t\tmap(filter => (filter === \"completed\" ? \"selected\" : \"\"))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprops: { innerText: \"Completed\" }\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t]),\n\n\t\t\thtml.button({\n\t\t\t\tattrs: {\n\t\t\t\t\tclass: \"clear-completed\",\n\t\t\t\t\thidden: props.tasks$.pipe(\n\t\t\t\t\t\tmap(tasks =>\n\t\t\t\t\t\t\tfilters.completed(tasks).length > 0 ? undefined : \"hidden\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\tprops: { innerText: \"Clear completed\" },\n\t\t\t\tevents: {\n\t\t\t\t\tasync click() {\n\t\t\t\t\t\tawait props.clearCompleted();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t]\n\t);\n}\n","import { Observable } from \"@hullo/core/observable\";\nimport { Atom } from \"@hullo/core/atom\";\nimport { deepMap } from \"@hullo/core/operators/deepMap\";\nimport { map } from \"@hullo/core/operators/map\";\nimport { combineLatest } from \"@hullo/core/combineLatest\";\nimport { html } from \"@hullo/dom/html\";\n\nimport { Task } from \"./Task\";\n\nexport function List(props: {\n\tlist$: Observable<Task[]>;\n\tonToggle: (idx: number) => any;\n\tonRename: (idx: number, label: string) => any;\n\tonRemove: (idx: number) => any;\n}) {\n\tconst edited$ = new Atom<number>(-1);\n\n\treturn html.ul(\n\t\t{\n\t\t\tattrs: {\n\t\t\t\tclass: \"todo-list\"\n\t\t\t}\n\t\t},\n\t\tprops.list$.pipe(\n\t\t\tdeepMap((task$, i) => {\n\t\t\t\tconst tmpLabel$ = new Atom(task$.unwrap().label);\n\t\t\t\ttask$.pipe(map(task => task.label)).subscribe(tmpLabel$);\n\t\t\t\tlet editInput: HTMLInputElement | null = null;\n\t\t\t\treturn html.li(\n\t\t\t\t\t{\n\t\t\t\t\t\tattrs: {\n\t\t\t\t\t\t\tclass: combineLatest<[Task, number]>([task$, edited$]).pipe(\n\t\t\t\t\t\t\t\tmap(([task, edited]) =>\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\"todo\",\n\t\t\t\t\t\t\t\t\t\ttask.completed ? \"completed\" : \"active\",\n\t\t\t\t\t\t\t\t\t\ti === edited ? \"editing\" : \"viewing\"\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t.join(\" \")\n\t\t\t\t\t\t\t\t\t\t.trim()\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t[\n\t\t\t\t\t\thtml.div({ attrs: { class: \"view\" } }, [\n\t\t\t\t\t\t\thtml.input({\n\t\t\t\t\t\t\t\tattrs: {\n\t\t\t\t\t\t\t\t\tclass: \"toggle\",\n\t\t\t\t\t\t\t\t\ttype: \"checkbox\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\t\tchecked: task$.pipe(map(task => task.completed))\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tevents: {\n\t\t\t\t\t\t\t\t\tasync click(_event) {\n\t\t\t\t\t\t\t\t\t\tawait props.onToggle(i);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\thtml.label({\n\t\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\t\tinnerText: task$.pipe(map(task => task.label))\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tevents: {\n\t\t\t\t\t\t\t\t\tasync dblclick() {\n\t\t\t\t\t\t\t\t\t\tawait edited$.next(i);\n\t\t\t\t\t\t\t\t\t\tif (editInput) {\n\t\t\t\t\t\t\t\t\t\t\teditInput.focus();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\thtml.button({\n\t\t\t\t\t\t\t\tattrs: { class: \"destroy\" },\n\t\t\t\t\t\t\t\tevents: {\n\t\t\t\t\t\t\t\t\tasync click(event) {\n\t\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\t\tawait props.onRemove(i);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t]),\n\t\t\t\t\t\thtml.input({\n\t\t\t\t\t\t\tref(e) {\n\t\t\t\t\t\t\t\teditInput = e as HTMLInputElement;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tderef() {\n\t\t\t\t\t\t\t\teditInput = null;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tattrs: { class: \"edit\", type: \"text\" },\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tvalue: tmpLabel$\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tevents: {\n\t\t\t\t\t\t\t\tasync input(event) {\n\t\t\t\t\t\t\t\t\tawait tmpLabel$.next(\n\t\t\t\t\t\t\t\t\t\t(event.target as HTMLInputElement).value\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tasync blur() {\n\t\t\t\t\t\t\t\t\tawait props.onRename(i, tmpLabel$.unwrap());\n\t\t\t\t\t\t\t\t\tawait edited$.next(-1);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tasync keydown(event) {\n\t\t\t\t\t\t\t\t\tif (event instanceof KeyboardEvent && event.keyCode === 13) {\n\t\t\t\t\t\t\t\t\t\tawait props.onRename(i, tmpLabel$.unwrap());\n\t\t\t\t\t\t\t\t\t\tawait edited$.next(-1);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (event instanceof KeyboardEvent && event.keyCode === 27) {\n\t\t\t\t\t\t\t\t\t\tawait edited$.next(-1);\n\t\t\t\t\t\t\t\t\t\tawait tmpLabel$.next(task$.unwrap().label);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t]\n\t\t\t\t);\n\t\t\t})\n\t\t)\n\t);\n}\n","import { html } from \"@hullo/dom\";\nimport { Task } from \"./Task\";\nimport { map } from \"@hullo/core/operators/map\";\nimport { filters } from \"./filters\";\nimport { List } from \"./List\";\nimport { Observable } from \"@hullo/core/observable\";\nimport { distinctStrictEqual } from \"@hullo/core/operators/distinct\";\n\nexport function Main(props: {\n\ttasks$: Observable<Task[]>;\n\tselectedTasks$: Observable<Task[]>;\n\n\tonToggleAll: () => any;\n\tonToggle: (idx: number) => any;\n\tonRename: (idx: number, label: string) => any;\n\tonRemove: (idx: number) => any;\n}) {\n\treturn html.section(\n\t\t{\n\t\t\tattrs: {\n\t\t\t\tclass: \"main\",\n\t\t\t\thidden: props.tasks$\n\t\t\t\t\t.pipe(map(tasks => (tasks.length === 0 ? \"hidden\" : undefined)))\n\t\t\t\t\t.pipe(distinctStrictEqual)\n\t\t\t}\n\t\t},\n\t\t[\n\t\t\thtml.input({\n\t\t\t\tattrs: {\n\t\t\t\t\tid: \"toggle-all\",\n\t\t\t\t\tclass: \"toggle-all\",\n\t\t\t\t\ttype: \"checkbox\"\n\t\t\t\t},\n\t\t\t\tprops: {\n\t\t\t\t\tchecked: props.tasks$.pipe(\n\t\t\t\t\t\tmap(tasks => filters.active(tasks).length > 0)\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\tevents: {\n\t\t\t\t\tasync input(event) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tawait props.onToggleAll();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\thtml.label({\n\t\t\t\tattrs: { for: \"toggle-all\" },\n\t\t\t\tprops: { innerText: \"Mark all as complete\" }\n\t\t\t}),\n\t\t\tList({\n\t\t\t\tlist$: props.selectedTasks$,\n\t\t\t\tasync onToggle(idx) {\n\t\t\t\t\tawait props.onToggle(idx);\n\t\t\t\t},\n\t\t\t\tasync onRename(idx, label) {\n\t\t\t\t\tawait props.onRename(idx, label);\n\t\t\t\t},\n\t\t\t\tasync onRemove(idx) {\n\t\t\t\t\tawait props.onRemove(idx);\n\t\t\t\t}\n\t\t\t})\n\t\t]\n\t);\n}\n","import { Task } from \"./Task\";\n\nexport const filters = {\n\tall: (tasks: Task[]) => tasks,\n\tactive: (tasks: Task[]) => tasks.filter(task => !task.completed),\n\tcompleted: (tasks: Task[]) => tasks.filter(task => task.completed)\n};\n","import { mount } from \"@hullo/dom\";\nimport { App } from \"./App\";\n\nmount(document.getElementById(\"app\")!, App());\n"],"sourceRoot":""}